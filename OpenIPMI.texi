\input texinfo   @c -*-texinfo-*-
@setfilename OpenIPMI.info
@settitle OpenIPMI Interface Users's Guide
@setchapternewpage odd

@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{OpenIPMI User's Guide}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002 MontaVista Software
@end titlepage

@node    Top,       Intro to IPMI,         , (dir)

This document describes OpenIPMI, and IPMI abstraction layer that makes
IPMI easier to use, and allows OEM vendors to supply plugins to support
their special sensors and controls.

@menu
* Intro to IPMI::     A little about IPMI
* Concept Index::     
* OpenIPMI Concepts::
* Using OpenIPMI::
* How to Write OEM Plugins::
* Internals::
* Debugging Your Application::
* Glossary::
@end menu

@node    Intro to IPMI, OpenIPMI Concepts, Top,      Top
@comment node-name,     next,          previous, up
@chapter Intro to IPMI
@cindex intro

If you have read the IPMI spec, you are probably thoroughly confused
about IPMI.  The IPMI spec doesn't provide the high-level expected usage
of IPMI.  This chapter covers that information.  It provides a
high-level view of how IPMI is expected to be used.

@menu
* Things in IPMI::
* How IPMI Works::
* The User View::
@end menu

@node    Things in IPMI, How IPMI Works, Intro to IPMI, Intro to IPMI
@section Things in IPMI

IPMI is a specification for system monitoring.  It monitors entities in
your system with sensors.  Sensors can generate events such as state
changes or out of range conditions which may be stored in a System Event
Log (SEL) and forwarded to listening parties.  Information about the
system may be stored in Sensor Data Records (SDRs), which hold
information about a whole lot more things than sensors.  Various
Management Controllers (MCs) may exist in the system, these are the
intelligent devices that handle the sensors in the system.  The main MC
is the Baseboard Management Controller (BMC), it is what what the
external software interacts with directly, through a system
interface, a LAN connection, a serial connection, etc.  Messages to
other MCs in the system go through the BMC.

Note that a sensor may be something you don't traditionally think of as
a sensor.  Beyond standard analog sensors, there are sensors for the
presence of entities, sensors for buttons, sensors for predictive
failures, and a host of other things.  An MC may generate events as the
BIOS on the board it's on goes through it's processing.  In general, a
sensor may be attached to anything that can be sensed or monitored.

Inside the system, the various devices generally communicate over an
Intelligent Peripheral Management Bus (IPMB).  So if you need to message
a specific sensor, you will send a message to the BMC asking it to
forward the message to the proper MC over the IPMB bus.  The destination
is specified via an IPMB address.

IPMB addresses contain a slave address, which identifies the MC.  They also
contain a Logical Unit Number (LUN), which identifies an entity inside
the MC.

Some types of connections need to be authenticated, you will need to
provide userids and passwords for the BMC to accept your messages.
Several different authentication algorithms are available.

@node    How IPMI Works, The User View, Things in IPMI, Intro to IPMI
@section Things in IPMI

So now we've got a BMC, MCs, and things like that.  But how are you
expected to use raw IPMI?

The first things you must do, of course, it connect to the BMC.  If it's
a direct SMI connection (A SMIC, KCS, or BT interface, or perhaps a
non-standard serial interface), you just open the driver on the
operating system and start messaging.  If it's a LAN-type connection,
you have to go through an authentication sequence.  One you have a
connection to the BMC, things are pretty much the same no matter what
interface you have.  There are a few messaging for doing special
controls on a LAN interface, but they don't generally matter to the
user.

Once the connection to the BMC is up, the user should query to see what
channels the BMC supports.  For 1.5 and later, it gets this from a
command.  For 1.0, it gets it from the main SDR repository.

Once you are connected, you should scan the SDRs in the main SDR
repository for any entities.  I would not expect there to be any sensors
there, though, because it doesn't make sense to put sensors there.
There may be some though.  This is theh place where entities and entity
relationships are documented.

Sensors should be in the device SDR repository, which should be scanned
next.  This allows the user to discover the sensors in the system.  Note
that the sensors may point to entities that don't exist, those entities
need to be handled when they are detected.

After this point in time, the interface could be deemed to be up.
However, there's still more to do.

If the interface supports an event queue, the user will have to poll it
(if the driver doesn't deliver them asynchronously, that is).  If the
interface doesn't support an event queue the user should periodically
scan the system event log for new events.  (Note that even if it does
support an event queue, the user should still poll the system event log
in case they missed any events coming in.)

Also, the user should start scanning the IPMB bus with broadcast get
device id commands to detect any MCs on the bus.

This is what OpenIPMI does for you.  Beyond this, it also represents the
sensors, controls, and entities in a nice OO fashion, and it handles the
details of addressing, message routing, and other things you don't
really care about.  It lets you get right at the sensors and entities.

@node    The User View, , How IPMI Works, Intro to IPMI
@section The User View

A bunch of acronyms have just been introduced, along with a lot of vague
concepts, and some description about how to use IPMI.  The nice thing is
that the user of OpenIPMI doesn't really have to know about all these
things.  From the user's point of view, the entity provides the central
framework for everything else.  Sensors monitor entities.  Entities may
be present or absent.  When you connect to an interface, OpenIPMI takes
care of detecting the entities in the system and reporting them to you.
You may register to be told when entities are added or removed from the
database.  Note that an entity may be present in the database, but not
present in the system, the reporting from only gives the presence in the
database, not physical presence in the system.

The user must know about two other OpenIPMI concepts: connections and
domains.  A connection provides the interface to the IPMI system.  In
essence, it is the BMC connection.  You must allocate a connection and
create a domain with it.  (In the future it will be one or more
connections when multiple interfaces to a domain are supported.)  A
domain represents a set of devices on a bus (like IPMB) whose entities
will be unique.  For instance, a chassis with a lot of cards plugged
could be a domain, each card could be an entity and then create it's own
sub-entities, but they will be designed so the entity id's don't
collide.

Though the user doesn't have know the inner details of IPMI addressing
and messaging, they do need to know about entities and sensors.
OpenIPMI mainly focuses on representing the entities and sensors in
convenient ways.  The user still needs to understand the capabilities of
sensors, how the sensors advertise those capabilties, and the things
that can be done to the sensors.

You may register with an entity to be told when it's physical presence
in the system changes.  Some devices (like power supplies) are
field-replacable while the system is running, these are called Field
Replacable Units (FRUs).  They may have sensors that monitor them, but
those sensors may not be active if the device s not physically present
in the system.

Sensors are also automatically detected and reported.  This is done
through entities, you register with an entity to be told when a sensor
has been added or removed.  IPMI defines special types of sensors called
Presence Sensors, these report if an entity is present in the system.  A
presence sensor is @emph{not} reported to the user, OpenIPMI attaches
these to the entity directly and uses them to detect the presence of the
entity.

Sensors provide a lot of functions depending on their type.  Threshold
sensors monitor "analog" things like temperature, voltage, or fan speed.
Discrete sensors monitor events or states, like the previously
introduced presence sensor, software initialization progress, or if
external power is present to the system.

Threshold sensors report their readings in values from 0-255.  OpenIPMI
makes every effort to convert this to a floating-point value for you to
use.  IPMI defines standard ways to convert values using various
formulas.  OpenIPMI implements all these and provides ways for OEM
functions to plug in to provide their own converters.  If you have a
sensor that cannot be represented using the standard mechanisms, you
need to get the OEM algorithms for this and implement them in an OEM
plug-in for the sensors.

You may enable events on a threshold sensor by specifying values (called
thresholds) where you want the sensor to report an event.  Then you can
enable the events for the specific thresholds.  Not all sensors support
all thresholds, some cannot have their events enabled and others cannot
have them disabled.  The capabilities of a sensor may all be fetched
by the user to determine what it can do.

Threshold sensors may have hysteresis, meaning that when the sensor goes on
above or below the specified value, the transition point where the
threshold goes off is somewhat below or above the given value.  For
instance, if you want a fan speed sensor to go off when it goes below
150 RPM, if the fan is hanging right around 150 RPM, the sensor may be
constantly sending you events as it goes slightly above and slightly
below 150 RPM, which is bad because it can overload the system
management software.  The hysteresis for the fan might be set at 10 rpm,
which means that if the speed goes below 150 RPM, then it must go above
160 RPM for the threshold to be disabled.  Hysteresis may be settable or
may be fixed for the sensor.

Discrete sensors report their readings in a 16-bit bitmask, each bit
representing a dicrete value.  You enable events on the sensor by
specifying which discrete values you want to generate events.  Like
threshold sensors, these events may or may not be user-controllable.
That information may be fetched by the user.

@c **********************************************************************
@node    OpenIPMI Concepts, Using OpenIPMI,  Intro to IPMI, Top
@chapter OpenIPMI Concepts

OpenIPMI is an event-driven library that is designed to be relatively
operating system independent.  If you have written control systems or
things like that in the past, you will be quite familiar with
event-driven systems and may skip to the next section.  If not, you want
to read this.  Event-driven systems may seem a little unusual, but they
are accepted practice and by far the best way to build control systems.

@menu
* Event-Driven Systems::
* The OS Handler::
* Messaging Interfaces::
* Error Handling::
* Locking::
* OpenIPMI Objects::
@end menu

@node    Event-Driven Systems, The OS Handler, OpenIPMI Concepts, OpenIPMI Concepts
@section Event-Driven Systems

In an event-driven system, you never stop and wait for something to
happen.  If you are not used to this, you are probably used to writing
code like this:
@example
  while (true) @{
    wait_for_input();
    perform_op1();
    wait_for_op1_results();
    perform_op2();
  @}
@end example
This is fairly straightforward, but it has some problems.  What if
another more important input comes in while you are waiting for the
results of @code{perform_op1()}?  Now @code{wait_for_op1_results()} will
have to handle input, too, and somehow return and say something is
happening.  The loop will then have to somehow handle multiple
operations in progress.  And this is a simple example, what if there
were hundreds of possible inputs, each with their own result handler,
and each had to go through several states?  You could assign each to a
thread, but if you have thousands of possible pending operations in a
system, that many threads may thrash your system and render it
inoperable, probably right at the time you need it most (since a lot of
things are going on).

In an event-driven system, instead you would say:
@example
  init()
  @{
    <initialize input_data>
    register_for_input(op1_handler, input_data);
  @}
  op1_handler(input_data)
  @{
    <allocate and initialize op_data>
    perform_op1(..., op2_handler, op_data);
  @}
  op2_handler(op_data)
  @{
    perform_op2();
    <free op_data>
  @}
@end example
As you see, when you start an operation, you provide the next thing to
call when the operation completes.  The functions passed around are
called ``callbacks''.  You allocate and pass around chunks
of data to be passed to the handlers.  And you register input handler
that get called when certain event occur.  So the code runs in short
non-blocking sections, registers for the next operation, then returns
back to some invisible main loop that handles the details of scheduling
operations.  This may seem more complicated than the previous example,
but it has a large number of advantages:
@enumerate
@item The system is almost always ready to handle input.  For instance,
user-interface systems (like most widget sets) are almost always
event-driven, this
makes them much more ``live'', since they are always ready to handle
user input.
@item This system can handle multiple operations simultaneously without
threads.  In general, threaded systems are less reliable and more
complicated, unless you need priorities or scalability on SMP, why use
them?  And even if you use them, you can have much better control over
what is running in the system.
@item If you are building a redundant system with data replication, this
gives you a natural way to hold your data, know when to transfer it over
to the mate system, and continue an operation on the mate system.
@item If you track the data, it's easy to monitor every operation
occuring in the system, stop an operations, or whatever.
@item It's much easuer to detect and manage overload situations in an
event driven system.  Event-driven systems have event queues of things
waiting to be processed.  You can put things in the queue and watch the
queue length.  If the queue length gets too big, you are in overload,
and can intelligently decide which events you want to throw away, based
on priority, time to live, or some other criteria.
@end enumerate

In general, a threaded system is easier to conceptually understand until
you understand event-driven methods.  An event-driven system is almost
always easier to correctly implement.

Note that event-driven systems don't preclude the use of threads.
Threads may be vastly overused, but they are important.  You could, for
example, allocate one event loop thead per CPU to help scale your
system.  You need to use threads to manage priorities.  Some inputs may
be more important than others, so you may have an event loop for each
priority and feed them that way.  You have a thread per CPU, and/or a
thread per priority, but you don't need a thread per operation.

This is often called ``state-machine programming'' since most control
systems are state-machine based, and this is a natural way to implement
a state machine.  The @code{op_data} holds the state of the state
machine, each input gets @code{op_data}, looks at the current state, and
decides what to do next.

The OpenIPMI library is completely event-driven.  It has no internal
blocking operations, and it expects that anything it calls will not
block.  IPMI messaging and operating system primitives are provided
through external plug-in pieces.

If a library function that takes a callback does not return an error,
the callback is guaranteed to be called, even if the object the call is
associated with goes away.  If it goes away, a NULL may be passed to the
callback, but the @code{cb_data} will still be valid.

@node    The OS Handler, Messaging Interfaces, Event-Driven Systems, OpenIPMI Concepts
@section The OS Handler

The OS handler provides services for the OpenIPMI library.  These
services are:
@table @samp
@item Input Callbacks
The OpenIPMI code uses the ``file descriptor'' concept of *nix, input
devices are numbered.  This is not used internally in the library, but
it is used by the messaging interfaces, so the messaging interfaces and
OS handler may implement their own conventions for these numbers.  But
this provides a way to register to receive input from devices.

@item Timers
OpenIPMI times everthing (as it should), thus it needs timers.

@item Locks
OpenIPMI does not require locks, you may leave the operations NULL and
they won't be used.  However, if you are doing multi-threaded
operations, you should provide locks.  The locks should be recursive
(the same lock may be claimed multiple times by the same thread).  You
need to provide read/write locks operations, although these may be
normal locks (the system will just be less responsive).

@item Condition Variables
These are condition variables like the ones specified in POSIX threads.
Although OpenIPMI does not use condition variables (since it never waits
for anything) it may be convenient for other things to have them.
OpenIPMI does not use them, and if nothing in your system needs them,
they need not be provides.

@item Random Data
For certain operations, OpenIPMI needs random data.
@end table

@node    Messaging Interfaces, Error Handling, The OS Handler, OpenIPMI Concepts
@section Messaging Interfaces

Messaging interfaces provide the low-level interface to the BMC.  It can
be through a LAN, a system interface, a serial port, or a host of other
possible interfaces.

@node    Error Handling, Locking, Messaging Interfaces, OpenIPMI Concepts
@section Error Handling

Almost all OpenIPMI calls that do anything besides fetch a piece of
local data will return an integer error value.  A zero means no error.
Two types of errors are returned, system errors (which are standard Unix
errno values) and IPMI errors (which are the standard IPMI error codes).
You can use the macros @var{IPMI_IS_OS_ERR} and
@var{IPMI_IS_IPMI_ERR} to tell the type of error, and
@var{IPMI_GET_OS_ERR} and @var{IPMI_GET_IPMI_ERR} to get
the actual error values.

Note that if your system doesn't have Unix-type error numbers, you will
have to provide those for the OpenIPMI library.

If a function returns an error, any callbacks provided to that function
will @emph{never} be called.  If a function that takes a callback
returns success, the callback will @emph{always} be called, even if the
object associated has ceased to exist.  If an object with outstandard
operations ceases to exist, all the callbacks for outstanding operations
will be called with ECANCELED as the error.  Errors are passed into many
callbacks, if an error is present the rest of the data in the callback
is probably not valid except for the @code{cb_data} variable you
provide, and possibly the object the callback is associated with.  The
object the callback is associated with may be NULL if it has ceased to
exist.

@node    Locking, OpenIPMI Objects, Error Handling, OpenIPMI Concepts
@section Locking

As mentioned before, you may or may not be using locking, @strong{but
you must read this section anyway.}  Locking here involves existance of
entities as well as normal locking.

The basic principle of locking is that if you are in a callback for an
IPMI object (an IPMI object is passed in the callback), that object is
locked and the system cannot change it.  In any callback for an object
owned by a particular domain, that object will be locked and anything it
belongs to will be locked.  So, for instance, in a callback for a
sensor, the sensor is locked, the entity the sensor belongs to is
locked, the management controller the sensor is on is locked, and the
domain the sensor is in will be locked.  No other sensors, entities, or
management controllers will necessarily be locked.  Outside of
callbacks, the library is free to change pointers, change information,
add and remove objects, or whatever it wants.

So how do you obtain a lock for an IPMI object?  If you are handling
incoming IPMI events you generally don't have to worry about this.  But
say you are handling outside input, such as a user interface.  What
then?  If the pointers can change, how do I keep a reference to
something?

OpenIPMI provides two identifiers for IPMI objects.  One is a pointer,
but a pointer is only good inside a callback.  The other is an OpenIPMI
id, the id is good outside callbacks.  But the only thing you can do with
an id is pass it to a function that will call a callback for you with
the pointer.  You can convert a pointer to an id (inside a callback, of
course) so you should do that if you need to save a reference to the
object.

This mechanism, though a little inconvenient, almost guarantees that you
will not forget to release a lock.  It nicely encapsulates the locked
operation in a function@footnote{This is how locking works in Ada95 and
Java, although their mechanisms are a little more convenient since they
are built into the language}.  You have to return from the function
unless you exit, longjmp, or throw an exception that falls through the
callback, and you shouldn't do those things.

You must do this whether you are using locking or not, because the
library uses this mechanism to determine whether the id you are holding
is good.  Once it converts the id to the pointer, your pointer is
guaranteed to be good until the function returns.

@node    OpenIPMI Objects, , Locking, OpenIPMI Concepts
@section OpenIPMI Objects

In OpenIPMI, the user deals with five basic objects: connections,
domains, entities, sensors, and control.

@subsection Connections

A connection provides the low-level interface to the system.  It is
usually a connection to a BMC in a system.  It handles getting IPMI
messages to the proper elements in the system.

@subsection Domains

The domain is the container for the system, the entities in the system
are attached to the it.  You create a domain with a connection to a
system; the domain handles the job of discovery of the things in the
system.

@subsection Entities

Entities are things that are monitored.  They may be physical things
such as a power supply or processor, or more abstract things such as the
set of all power supplies or the ambient air in a chassis.  Sensors
monitor entities, and controls are attached to entities.

Entities may be grouped inside other entities, thus an entity may have a
parent (if it is grouped inside another entity) and children (if it
contains other entities).  These relationships are abstract; you may
change them if it you like.  A raw system with no SDR data will not have
any relationships defined.  Relationships are stored in the SDR
repository, you may change them and store them back, if you like and if
the system supports that.

@subsection Sensors

Sensor monitor something about an object.  IPMI defines many types of
sensors, but groups them into two main categories: Threshold and
discrete.  Threshold sensors are ``analog'', they have continuous (or
mostly continuous) readings.  Things like fans speed, voltage, or
temperature.

Discrete sensors have a set of binary readings that may each be
independently zero or one.  In some sensors, these may be independent.
For instance, a power supply may have both an external power failure
and a predictive failure at the same time.  In other, they may be
mutually exclusive, such as the initialization state of a piece of
software.

@subsection Controls

Controls are not part of the IPMI spec, but are necessary items in
almost all systems.  They are provided as part of OpenIPMI so that OEM
code has a consistent way to represent these, and so OpenIPMI is ready
when the IPMI team finally sees the light and adds controls.
OpenIPMI defines many types of control: lights, relays, displays,
alarms, reset, power, fan speed, and identifiers.

For all controls except displays and identifiers, the control may
actually control more than one device.  With some controls, multiple
device may be controlled together and individual ones cannot be set (ie,
the same message sets all of them).  For these types of controls,
OpenIPMI represents them as a single control with multiple devices.
All the devices are read and set at once.

Lights are on/off colored devices, like an LED.  They may be
multi-color, but can only show one color at a time.  For instance, if
you work for Kmart, or you are managing a CompactPCI system with
hot-swap, you will have a blue light in your system.  You can search
through the controls to find a light that's blue.  Then, if a special
is on, or you want the operator to remove a card, you can light the blue
light.  Lights may blink, too.  Each light can have settings.  Each
setting describes a sequence of one or more transitions the light may go
through.

Relays are binary outputs.  Most telephony systems have them; they are
required by telephony specs.  They are simple on/off devices.

Displays are two-dimensional arrays of characters.  OpenIPMI allows you
to change individual characters at will.

Alarms are bells, whistles, gongs, or anything to alert the user that
something is wrong.

Reset controls are used to reset the entity to which they are attached.

Power controls can be used to control power to or from an entity.  A
power control on a power supply would generally control output power.  A
power control on a board would generally control input power to the
board.

Fan speed controls can be used to set the speed of a fan.

Identifier controls hold identification information for a system, such
as a chassis id, chassis type, geographic address, or whatever.

@c **********************************************************************
@node    Using OpenIPMI, How to Write OEM Plugins, OpenIPMI Concepts, Top
@chapter Using OpenIPMI

This chapter discusses how to use the OpenIPMI library.  Note that not
all the details of everything are covered.  See the include files for
details on the functions and types.  This covers the concepts so you can
understand the include files.

@menu
* Include Files::
* Initialization::
* The Connection::
* The Domain::
* Entities::
* Sensors::
* Controls::
* The System Event Log (SEL)::
* The Sensor Data Record (SDR) Repository::
@end menu

@node    Include Files, Initialization, Using OpenIPMI, Using OpenIPMI
@section Include Files

@subsection Files the normal user deals with

@table @samp
@item @file{ipmiif.h}
The main include file for OpenIPMI.  It contains the main functions the
user must deal with when working with the OpenIPMI library.  Almost
everything will include this.  It includes @file{ipmi_types.h} and
@file{ipmi_bits.h}, too, so you don't have to include those.

@item @file{ipmi_auth.h}
The file holding information about athentication algorithms.  You need
this if dealing with an authenticated interface.

@item @file{ipmi_bits.h}
Various values, mostly for sensors, used by the user.  @file{ipmiif.h}
includes this file, so you generally don't have to include it explicitly.

@item @file{ipmi_types.h}
Types for the basic IPMI objects.  @file{ipmiif.h} includes this file,
so you generally don't have to include it explicitly.

@item @file{ipmi_err.h}
Error values, both IPMI and system, as well as macros for interpreting
these.

@item @file{os_handler.h}
The os-specific handler types are defined here.  You must implement this
and supply it to the IPMI code.

@item @file{selector.h}
For *nix systems, This file a default mechanism for handling many of the
os-specific handler operations.

@item @file{log.h}
Holds definitions for the logging interface.

@subsection Files dealing with messaging interfaces

@item @file{ipmi_lan.h}
This is the LAN messaging interface, this contains the calls for
creating a LAN connection.

@item @file{ipmi_smi.h}
This is the messaging interface for talking to local IPMI interfaces
(like KCS), this contains the calls for creating an SMI connection.

@subsection Internal files that OEM code and messaging interfaces deal with

@item @file{ipmi_addr.h}
The file holding information about IPMI addresses.

@item @file{ipmi_conn.h}
This defines the interface for the messaging interfaces.

@item @file{ipmi_entity.h}
This defines internal entity interfaces.

@item @file{ipmi_control.h}
This defines internal control interfaces.

@item @file{ipmi_int.h}
This defines other miscellaneous internal interfaces.

@item @file{ipmi_domain.h}
This defines the internal interfaces for dealing with domains.

@item @file{ipmi_mc.h}
This defines internal interfaces for the management controllers.

@item @file{ipmi_msgbits.h}
This defines various IPMI messages.

@item @file{ipmi_oem.h}
This defines interfaces that OEM code can tie into.

@item @file{ipmi_sel.h}
This defines the internal interfaces for the SEL.

@item @file{ipmi_sdr.h}
This defines internal interfaces for the sdr repostiory.

@item @file{ipmi_sensor.h}
This defines internal interfaces for sensors.

@end table

@node    Initialization, The Connection, Include Files, Using OpenIPMI
@section Initialization

To initialize the OpenIPMI library, you must call @code{ipmi_init()} and
pass in an @var{os_handler_t} in to it.  OpenIPMI will use this OS
handler for global operations.  This @emph{must} be done before any
other OpenIPMI calls.

If you need to initialize any OEM libraries, do it right after the call
to @code{ipmi_init()}.

@node    The Connection, The Domain, Initialization, Using OpenIPMI
@section The Connection

The first thing you must do after initialization is create a connection
to the IPMI system.  The operation for this depends on the type of
connection, such as a LAN connection, a connection through a local
device driver, or an OEM connection.  See the information for the
specific connections for information on the connection.

Note that creating a connection does not actually establish a
connection, it just creates the data structures for the connection.  You
then hand the connection to a domain.  The domain will establish the
connection and get things rolling.

@node    The Domain, Entities, The Connection, Using OpenIPMI
@section The Domain

After you create a connection, you pass it into
@code{ipmi_init_domain()} to create a domain with the connection.  This
gives you back a domain that you can work with.  When the domain is
first created, it is not considered "up" though, you supply a callback
in the @code{ipmi_init_domain()} call which will tell you when the
connection comes up, the callback will also be used in the future to
tell you of state changes.  The id of the callback is also returned, you
can remove the callback with
@code{ipmi_domain_remove_con_fail_handler()}, and you can add more
callbacks with @code{ipmi_domain_add_con_fail_handler()}.

When the domain is given to you, the OpenIPMI library starts scanning
the IPMB bus to find all MCs on the bus.  As it finds them, it will scan
the sensors on the MC and add them to entities and create new entities
as necessary.  So when OpenIPMI hands you the domain, you probably don't
have everything in the chassis.  In fact, IPMI is dynamic, so you have
to be ready for changes as they happen.

OpenIPMI will rescan the bus for new MCs every 10 minutes.  It is
expected that OEM handlers can detect new MCs with custom events and add
the new MC sooner.

Events also come in through the domain.  In the setup done callback, you
should register for events with @code{ipmi_register_for_events()}, even
if you are not interested in them, because you need to delete them.
This means that your callback will receive all events that are not
attached to a sensor or otherwise handled by something inside OpenIPMI.
If an event is attached to a sensor, it will be delivered to a callback
associated with the sensor.  Note that you may get events on this
interface even if they are destined for a sensor, if the sensor doesn't
have a handler or if the event was not delivered to the user by another
mechanism.  This is so that the user can know the event exists and needs
to be deleted.

@node    Entities, Sensors, The Domain, Using OpenIPMI
@section Entities

Entities are the things that sensors monitor and controls can change
things on.  When a domain is first reported to you as operational, you
should register a callback using
@code{ipmi_domain_set_entity_update_handler()} to tell you when entities
are added or removed.  That way you can know about new entities as soon
as they are created.  If you wait until later to register the callback,
entities may have come into existance and you will miss them (although
you could find them after the fact using
@code{ipmi_domain_iterate_entities()}).

As mentioned before, entities may be present or absent.  IPMI defines a
rather convoluted algorithm to detect this, but you don't have to worry
about that.  Instead, you can use the
@code{ipmi_entity_set_presence_handler()} call to register a function to
be called whenever the presence of the entity changes.  You can use
@code{ipmi_entity_is_present()} to determine the current presence of the
entity.  Like the other callbacks, you should register the presence
callback in the entity creation callback.

Sensors and controls hang off entities.  OpenIPMI provides iterators so
you can scan all the sensors and controls on an entity.  It allows you
to register callbacks to tell you when sensors and controls are added to
or removed from the entity, using either
@code{ipmi_entity_set_sensor_update_handler()} or
@code{ipmi_entity_set_control_update_handler()}.  You sould do this in
the entity creation callback so you won't miss any sensors or controls
as they are detected.  You can also iterate over the current sensors and
controls using @code{ipmi_entity_iterate_sensors()} and
@code{ipmi_entity_iterate_controls()}.

Entities are hierarchical in nature.  An entity can have children
entities.  OpenIPMI allows you to create these relationships in the
local database and push them to the SDR database on the chassis, if you
like.  The next time it starts, it will pull them from the SDR database
and recreate the relationships.  If you have multiple power supplies in
a subchassis, or multiple processors on a board, the entity
relationships let you create nice containment relationships.  Use the
functions @code{ipmi_entity_iterate_children()} to find the children of
an entity, or @code{ipmi_entity_iterate_parents()} to iterate the
parents of an entity.  There doesn't seem to be a restriction in IPMI
that an entity only have one parent, thus the parent iteration call.

@node    Sensors, Controls, Entities, Using OpenIPMI
@section Sensors

Sensors, of course, are what IPMI is mostly about.  A sensor monitors
a characteristic of an entity.  IPMI specifies two main classes of
entities: threshold and discrete, described individually later.

You can tell the main type of sensor by doing an
@code{ipmi_sensor_get_event_reading_type()} call.  If this returns
@var{IPMI_EVENT_READING_TYPE_THRESHOLD}, it is a threshold sensor.
Otherwise, it is a discrete sensor.

It is important to note that all operations on a sensor are serialized,
each sensor has a queue of operations to perform, and it will only
perform one operation at a time on a sensor.  This is important, some
operations may require multiple messages to complete, and if you
intermix them it could cause confusion.  It also makes management of the
sensor easier for the user.

@menu
* Threshold Sensors::
* Discrete Sensors::
* Sensor Events::
* Hot Swap Sensor::
@end menu

@node    Threshold Sensors, Discrete Sensors, Sensors, Sensors
@subsection Threshold Sensors

Threshold sensors measure ``continuous'' data, data that generally
measure physical constants like voltage, temperature, etc.  IPMI calls
them ``threshold'' sensors because you can set thresholds for them.
Then a threshold is exceeded, some sensors can send an event to the
event receiver in the system.

Threshold sensors, unfortunately, are exceedingly complicated.  They
have a large number of settings, many options for conversion between the
discrete values and real values, and may support many optional
settings.  OpenIPMI attempts to hide much of this complexity, but it can
only go so far.

IPMI threshold sensors have the following settings:
@table @samp
@item Scanning
The sensor can be turned on and off using the status field of
@var{ipmi_thresholds_t} by setting or clearing
@var{IPMI_SENSOR_SCANNING_ENABLED} in the bitmask.  You have to use
@code{ipmi_sensor_get_sensor_init_scanning()} function to tell if you
need to turn scanning on or off.

@item Events
Some sensors can generate events, some can't.  For more details, see
@xref{Sensor Events}.

@item Thresholds
Some sensors support thresholds.  See below for more details.

@item Hysteresis
Some sensors have hysteresis values.  The function
@code{ipmi_sensor_get_sensor_init_hysteresis()} will tell you if you
need to initialize the hysteresis value for the sensor.  The
@code{ipmi_sensor_get_hysteresis support()} tells you what type of
hysteresis (if any) the sensor supports.

@end table

IPMI specifies the following thresholds:
@table @samp
@item non-recoverable
@item critical
@item non-critical
@end table

Their meanings are not really defined by IPMI, but they should be
obvious.  Each of these can have an upper and lower type, so for
instance you can have a critical upper and critical lower voltage
threshold.  As well, each of these may support an assertion and
deassertion event (an event when the value goes beyond the given range,
and another event when the value goes back within the given range, with
possible hysteresis).

In addition, the sensor may detect going above the given threshold (a
high-going threshold) or below the given threshold (a low-going
threshold).  This may seem redundant with the upper and lower
thresholds, but that's what the spec says.

The @code{ipmi_sensor_get_event_support()} tells what type of event
support the sensor has.  The sensor may support no events, only global
(per-MC) event enable and disable, event enable and disable for the
whole sensor, or event enable and disable per-threshold.  If the sensor
supports per-thresholds enables, it will also support enable for the
whole sensor.  All sensors that support events will support global
enables.

Of course, few sensors support all possible threshold values, and you
must be able to tell what they support.  You use the
@code{ipmi_sensor_threshold_assertion_event_supported()} and
@code{ipmi_sensor_threshold_deassertion_event_supported()} functions to
tell if the sensor supports a given threshold event.  The thresholds may
or may not be readable and settable, use the
@code{ipmi_sensor_threshold_settable()} and
@code{ipmi_sensor_threshold_readable()} to tell if a threshold can be
set or read.

To turn on and off thresholds and support for events and to set the
thresholds, you must first fill out an @var{ipmi_event_state_t}
structure using the various calls defined to do this.  Then call
@code{ipmi_sensor_events_enable_set()} to set the values.  The current
values may be fetched with @code{ipmi_sensor_events_enable_get()}.

To fetch the current value for a threshold sensor, use the
@code{ipmi_reading_get()} function.  The callback also returns the
current states of the various thresholds.  To see if a specific
threshold is out of range, use @code{ipmi_is_threshold_out_of_range()}
on the states passed in.

The SDR also has information about the accuracy, tolerance, min and max
values, etc. for the sensor.  Those function calls will return floating
point values (converted from raw values).  You need to read the IPMI
spec for the real meanings of all these things (from what little is
provided there), the functions are under the comment ``Sensor reading
information from the SDR'' in @file{ipmiif.h}.

OpenIPMI provides string values for many of the values in the SDR, so
the user doesn't have to provide it.  Note that the string may be set to
a valid value even if the numeric value in the SDR is an invalid or OEM
one, OEM code may update the string.  The string values are provided by
functions under ``Strings for various values for a sensor'' in
@file{ipmiif.h}.

@node    Discrete Sensors, Sensor Events, Threshold Sensors, Sensors
@subsection Discrete Sensors

IPMI represents discrete sensors as a bitmask, each bit representing a
possible discrete state.  One bit is reserved for other use.  This
limits you to 15 possible states for each sensor, but that's generally
not a big deal.  These are called ``offsets'' or ``states'' by the IPMI
spec, and are numbered from 0 to 14.

To get a reading from a discrete sensor, use the
@code{ipmi_states_get()} function.  The callback gives a variable
of @var{ipmi_states_t} type, use the @code{ipmi_is_state_set()} function
to tell if a specific discrete state is set.

The meanings of the reading's offsets are specified one of two ways.
This is specified by the @code{ipmi_sensor_get_event_reading_type()}.  A
value of @var{IPMI_EVENT_READING_TYPE_THRESHOLD} means a threshold
sensor.  A value of @var{IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC} means
the reading depends on the sensor type.  Values 0x2-0xc are generic
readings that can apply no matter what the sensor type, and are
specified in the IPMI spec.

If the reading offset meaning depends on the sensor type, you must call
@code{ipmi_sensor_get_sensor_type()} to retrieve the sensor type.  You
can use this to tell what the reading means.

You can also pass the offset of a reading (the state number that is set)
info @code{ipmi_sensor_reading_name_string()} to get string values for
the offsets.  This works for generic and for sensor-specific reading
types.  The string values may be valid even if the sensor is OEM or has
OEM values, because the OEM code can put there own strings in here.

@node    Sensor Events, Hot Swap Sensor, Discrete Sensors, Sensors
@subsection Sensor Events

Both threshold and discrete sensors support events, and they work about
the same for both, if you think of a threshold as a discrete state.
Individual discrete states may be armed to generate events.  However,
not all sensors support events, you need to use the
@code{ipmi_sensor_threshold_assertion_event_supported()},
@code{ipmi_sensor_threshold_deassertion_event_supported()},
@code{ipmi_sensor_discrete_assertion_event_supported()}, and
@code{ipmi_sensor_discrete_deassertion_event_supported()} calls to tell
if the particular sensor supports events on the given threshold or
state.

You can turn event generation on and off for sensors that support it
using the status field of @var{ipmi_event_state_t} by setting or
clearing @var{IPMI_SENSOR_EVENTS_ENABLED} in the bitmask.  You must
first initialize the structure with @var{ipmi_event_state_init}, then
set the specific events you are interested in using the
@code{ipmi_threshold_event_set()}, @code{ipmi_threshld_event_clear()},
@code{ipmi_discrete_event_set()}, and
@code{ipmi_discrete_event_clear()}, then call
@code{ipmi_sensor_events_enable_set()} to set the thresholds.  You can use
@code{ipmi_sensor_events_enable_get()} to fetch the current events
setting. You have to use @code{ipmi_sensor_get_sensor_init_events()}
function to tell if you need to initialize the events.  The
@code{ipmi_sensor_get_event_support()} function returns the support for
events.

You register to receive events for a sensor with
@code{ipmi_sensor_set_event_handler()}, which sets a callback that gets
called when an event comes in from the given sensor.  When the callback
comes in, the information from the event is presented, depending on the
sensor type.

For all sensor types, the direction (whether the state causing the event
is being asserted or deasserted) is present.  The offset specifies the
specific state or threshold that caused the event to be asserted.  The
@var{value_present} tells if a value is present, and whether it's raw or
cooked.

If an IPMI event (one that will now be in the SEL) caused this event,
then the event field will point to the event that caused this.  The
event is not automatically deleted from the SEL, you must do this
yourself.  This way, you can make sure the event has been properly
handled before removing it from the SEL.  Note that you @emph{must}
delete the events, or you SEL will fill up.

@node    Hot Swap Sensor, , Sensor Events, Sensors
@subsection Hot Swap Sensor

A discrete sensor for an entity may be a hot-swap requester, meaning
that it is a sensor that detects when the user wants to remove a board.
The @code{ipmi_sensor_is_hot_swap_requester()} call will return true if
the sensor passed in has the hot-swap requester.  It also returns the
offset for the hot-swap sensor, and whether the value will be asserted
when requested or not asserted when requested.

This way, upper-level software can detect if a sensor is a hot-swap
sensor and handle it properly.  Note that a sensor (such as a standard
slot sensor) may have more things in it than just the hot-swap
requester.

@node    Controls, The System Event Log (SEL), Sensors, Using OpenIPMI
@section Controls

As mentioned before, the IPMI standard does not currently define any way
to control output devices.  Of course, this is a huge hole, and is
likely to be filled in the future.  Until then, OpenIPMI defines an
abstraction for handling output devices.  This abstraction is hopefully
good enough for whatever the IPMI committee comes up with in the future,
but there will certainly be changes when it is specified.

Controls are input/output devices.  They currently do not generate any
type of events, they are values which can be set and (optionally) read.
These are relatively simple devices currently, although the IPMI
committee is sure to complicate things in the future.

It is important to note that all operations on a control are serialized,
each control has a queue of operations to perform, and it will only
perform one operation at a time on a control.  This is important, some
operations may require multiple messages to complete, and if you
intermix them it could cause confusion.  It also makes management of the
control easier for the user.

Unfortunately, some hardware does not have individually settable
devices, a set of devices may all be set at once.  This sometimes makes
sense, but usually makes things difficult for the user.  There's not
much OpenIPMI can do about this but pass the difficulty on up to the
user.  Thus, each control may have one or more instances of a device it
controls.  All these devices must be set at once, you cannot
individually set the devices inside one control.

Most controls have individually settable values that are integers.  Some
controls, namely displays and identifiers, have special needs and are
thus represented specially.

@menu
* Simple Controls::
* Lights::
* Fan Speed::
* Identifiers::
* Displays::
* Hot Swap Control::
@end menu

@node    Simple Controls, Lights, Controls, Controls
@subsection Simple Controls

Simple controls are on/off devices, the values provided are binary
values.  They are different because they control different types of
devices.  These are:

@table @samp
@item Relays - Generally telco relays on a chassis, but any type of relay.
@item Alarms - Visual or audible devices to get a user's attention.
@item Reset - The reset line on a board or device.
@item Power - The power output from a power supply, or power input to a
        device.
@end table

@node    Lights, Fan Speed, Simple Controls, Controls
@subsection Lights

Lights are slightly more complicated than simple devices.  Lights have
colors and blinking settings that must be represented.  Each setting is
represented by a single integer value, and a setting is a series of one or
more transitions the light will go through.  Each transition has a color
and duration.  And, of course, more than one light may be supported in a
single control.

The @code{ipmi_control_get_num_light_settings()} function returns the
number of settings a specific light has.  These are defined to be
continuous, if it reports 6, for instance, then the light will have
settings 0-5.

The @code{ipmi_control_get_num_light_transitions()} function returns the
number of transitions for a setting.

The @code{ipmi_control_get_light_color()} function returns the color a
light will be at a specific setting.

The @code{ipmi_control_get_light_color_time()} function returns the time in
milliseconds the transition is valid, before it goes to the next
transition.  This is used to represent blinking modes.  For instance, if
an LED in setting 4 blinks red for 100ms, green for 200ms, then off for
a second, then setting 4 will have 3 transitions, the first will be red
with 100, the second will be green with 200, the last will be black with
1000.

If this seems complicated, well, it is.  Sorry, there's a lot to
represent here.

@node    Fan Speed, Identifiers, Lights, Controls
@subsection Fan Speed

Fan speed allows the user to control the speed of a fan.  FIXME - This
is still TBD, need ways to find the min/max values and number of
settings.

@node    Identifiers, Displays, Fan Speed, Controls
@subsection Identifiers

Identifiers are things on a device that identify characteristics of that
device.  For instance, a unique serial number or a device type would be
identifiers.  These are represented as an array of unsigned characters,
as some identifiers may be very large.  The length may be variable,
too.

The function @code{ipmi_control_identifier_get_val()} and
@code{ipmi_control_identifier_set_val()} let you read and (optionally)
change the value of an identifier.  If you need to know the maximum
length, the function @code{ipmi_control_identifier_get_max_length()}
returns that.  The actual length is returned in the reading when you get
it.

@node    Displays, Hot Swap Control, Identifiers, Controls
@subsection Displays

FIXME - displays are TBD.

@node    Hot Swap Control, , Displays, Controls
@subsection Hot Swap Control

A control may be the indicator used to tell the user it's safe to remove
a hot-swap device (like the blue LED in Compact PCI).  If an indicator
is the hot-swap indicator, it should be a single LED, and the function
@code{ipmi_control_is_hot_swap_indicator()} will return true for it.

@node    The System Event Log (SEL), The Sensor Data Record (SDR) Repository, Controls, Using OpenIPMI
@section The System Event Log (SEL)

The SEL on a system receives all the events from a system and stores
them in a non-volatile store.  Depending on the capabilities of the BMC,
these may also have been received via an event message from the system
event queue.  OpenIPMI manages the received events, scans the SEL
periodically, and delivers the messages.  It discards duplicates.
Events that OpenIPMI can correlate to a specific sensor or control will
be delivered to the user through that sensor/control.  Events it cannot
interpret properly will be delivered through a generic interface for the
domain.

OpenIPMI keeps a local copy of the SEL in memory, but it doesn't
currently use very efficient methods to manage it.  The user should
receive the events and delete them in a timely manner to keep the SEL
small.  Note that if your SEL entity in your system doesn't support
deleting individual entries, then you must deleted @emph{all} the local
entries in the local copy of the SEL before OpenIPMI will clear the
entries from the SEL in the device.

When OpenIPMI scans the MCs, it checks the SEL device capabilities bit
and sets up an SEL for each MC that has that bit set.  This means that
multiple MCs may have an SEL.  When traversing the SEL, OpenIPMI will go
through @emph{all} the SEL devices on all MCs.  Also, events have the id
of the MC they came from so they can be traced back to their source.

The @code{ipmi_register_for_events()} function allows you to get events
OpenIPMI couldn't correlate to a sensor.  As well, the functions
@code{ipmi_domain_first_event()}, @code{ipmi_domain_last_event()},
@code{ipmi_domain_next_event()}, and @code{ipmi_domain_prev_event()} let you
iterate through the logs in the local representation of the SEL.

@node    The Sensor Data Record (SDR) Repository, , The System Event Log (SEL), Using OpenIPMI
@section The Sensor Data Record (SDR) Repository

OpenIPMI has code to manage the SDR Repository on the machine.

FIXME - this section needs information.

@node    How to Write OEM Plugins, Debugging Your Application, Using OpenIPMI, Top
@chapter How to Write OEM Plugins

Many things need to be represented that are not currently part of IPMI.
That's life, no standard can do everything.  Thus, OEM code needs to be
written for handling specific MCs.  In general, the MC is the primary
place that OEM code ties in.

An example of an OEM plugin is given in @file{example_oem.c}, it
contains a lot of useful info (including an example of how to do direct
I2C access and represent it as a sensor).

An OEM handler should register itself with the
@code{ipmi_register_oem_handler()} function.  It registers with a
manufacturer id and product id.  When an MC with those values is
detected, the OEM handler supplied in the function is called.  Then the
OEM handler can perform the functions it needs to do for that MC.

@menu
* Fixups::
* Non-Standard Sensors::
* OEM Controls::
* Special Strings::
* Data Conversion::
* Events::
* Using IDs in OEM Code::
* Sensor and Control Operation Queues::
* SDR Repository and OEM Code::
@end menu

@node    Fixups, Non-Standard Sensors, How to Write OEM Plugins, How to Write OEM Plugins
@section Fixups

Well, it happens.  Some bit is set wrong in the MC, or in a sensor SDR,
and that screws things up.  OEM code can directly fix values in the MC
using the calls in @file{ipmi_mc.h}.

For sensors, the OEM code can register to be told when new sensors are
added via the @code{ipmi_mc_set_oem_new_sensor_handler()} function.  It
should do this in the main OEM callback.  Every sensor that comes from
that MC will be supplied as it is detected from the device SDRs.  The
OEM code can then fix values in the code.  Note that any sensors from
the main SDR repository will not be called this way, since they will
already exist before the MC is detected.  If these exist, the OEM code
will have to scan the existing sensors and fix them up.

@node    Non-Standard Sensors, OEM Controls, Fixups, How to Write OEM Plugins
@section Non-Standard Sensors

Some sensors may not be properly represented in the SDR, or perhaps
there's some sensor on the I2C bus that doesn't have an MC managing it,
or perhaps a sensor that is accessed in a non-standard way.  Although
this is not how IPMI is supposed to work, OEM code can handle this and
represent these sensors as though they were standard IPMI sensors.

During the process of adding sensors and entities, the OEM code should
claim the entity lock in the MC using @code{ipmi_domain_entity_lock()},
and unlock it with @code{ipmi_domain_entity_unlock()} to keep the entity
list from changin while this is happening.

If the entity that holds the sensor doesn't exist, you will need to
create it with @code{ipmi_entity_add()}.  It should create any
parent-child relationships as required using
@code{ipmi_entity_add_child()}.  If the entity already exists, it needs
to be found, and a lock for the entity needs to be held.

OEM code can allocate a sensor using
@code{ipmi_sensor_alloc_nonstandard()}, then fill in all the values for
the sensor.  Sensor functions that need to send messages are
polymorphic, the @var{ipmi_sensor_cbs_t} structure defines all the
functions for a sensor.  You can fetch the current callbacks with
@code{ipmi_sensor_get_callbacks()}, change them, then set them with
@code{ipmi_sensor_set_callbacks()}.  The sensor will keep a copy of the
callbacks, so you don't have to allocate or manage this data.  This way,
you can supply your own version of these callbacks and override the
standard functions.

Sensors have an OEM pointer that the OEM code can use, the functions
@code{ipmi_sensor_set_oem_info()} and @code{ipmi_sensor_get_oem_info()}
set and retrieve this value.  A cleanup handler may be provided, if not
NULL this will be called with the sensor and OEM info when the sensor is
destroyed.

After the sensor has been set up, it can be added to the MC with
@code{ipmi_sensor_add_nonstandard()}.  These sensors are added in as LUN
4 to separate them from the normal sensors.  You must provide the entity
for the sensor, the MC it belongs to, and a sensor number.  The sensor
number is important, if you need to create an ID for the sensor (as
described in @xref{Using IDs in OEM Code}.) you need to be able to
determine the number for the sensor.  You may also provide a handler to
be called when the sensor is destroyed.

@node    OEM Controls, Special Strings, Non-Standard Sensors, How to Write OEM Plugins
@section OEM Controls

Because IPMI doesn't define output devices, all controls are
non-standard.  But they still need to be represented.  Controls work
just like sensors as defined in @xref{Non-Standard Sensors}, see that
for details on how to add your own sensors.

@node    Special Strings, Data Conversion, OEM Controls, How to Write OEM Plugins
@section Special Strings

As described in @xref{Fixups}, sensors can be detected as they are added
to the local database.  If the sensor is an OEM type, has it's own
units, or whatever, they can set their own strings for
these values.  The functions are defined in ``Custom sensor strings''.

Also, custom offsets may also have their own strings defined.  You must
override the @var{ipmi_sensor_reading_name_string} in the sensor
callbacks and provde you own function to convert the readings to
strings.

@node    Data Conversion, Events, Special Strings, How to Write OEM Plugins
@section Data Conversion

As described in @xref{Fixups}, sensors can be detected as they are added
to the local database.  If a sensor has a custom data conversion
function, it can provide a converter by overriding the
@var{ipmi_sensor_convert_from_raw} and @var{ipmi_sensor_convert_to_raw}
variables in the sensor callbacks.

@node    Events, Using IDs in OEM Code, Data Conversion, How to Write OEM Plugins
@section Events

An MC with an SEL may need custom handling for incoming events.  The
@code{ipmi_mc_set_sel_oem_event_handler()} call allows the OEM code to
set a handler that will be called when a new event is stored in the MC's
SEL.  If this function returns 1, that means the function handled the
event and no more handling should occur on the event.  If these function
return 0, the code will continue event handling.

An MC may also send custom events that might need to be handled in a
special way.  The @code{ipmi_mc_set_oem_event_handler()} will set a
callback to receive events that come from the MC.  If this function
returns 1, that means the function handled the event and no more handling
should occur on the event.  If these function return 0, the code will
continue event handling.

Note that if the OEM code handles an event but doesn't deliver it to the
user, it should call @code{ipmi_handle_unhandled_event()} so that the
user can be informed of the event (and thus can delete it if they
like).

Also, OEM code should ignore events with old timestamps (before the
startup of the system).  The OEM code can fetch the event from the
timestamp, and it can get the SEL timestamp at startup using
@code{ipmi_mc_get_startup_SEL_time()}.

@node    Using IDs in OEM Code, Sensor and Control Operation Queues, Events, How to Write OEM Plugins
@section Using IDs in OEM Code

OEM code may need to be able to create its own IDs to lock an entity.
For instance, if a custom even comes in and a lock need to be claimed
for an object, it may fill in an id structure.  The @file{ipmi_types.h}
file holds the definitions for these structures, they need to be filled
out completely.

@node    Sensor and Control Operation Queues, SDR Repository and OEM Code, Using IDs in OEM Code, How to Write OEM Plugins
@section Sensor and Control Operation Queues

As described in @xref{Sensors}, operations on sensors (and controls) are
serialized.

Each sensor and control has an operation queue, or opq.  The OEM code
should use this opq to perform operations that do messaging.  OpenIPMI
handles the locking for the sensors and controls, so this actually makes
it more convenient to use.

If OEM code needs to send a command for a sensor, it should use the
functions defined to do that for sensors and controls.  That way,
OpenIPMI can handle the locking of the sensor or control for the OEM
code.

The section in @file{ipmi_sensor.h} named ``Operations and callbacks for
sensor operations'' and the section in @file{ipmi_control.h} named
``Operations and callbacks for control operations'' describes this in
detail.

@node    SDR Repository and OEM Code, , Sensor and Control Operation Queues, How to Write OEM Plugins
@section SDR Repository and OEM Code

OpenIPMI has OEM plugins that allow the OEM code to handle OEM SDR
records and generate their own SDR records.  Sensors and entities have
polymorphic calls that are called when an SDR entry is written to the
SDR respository for one of them.

FIXME - need to finish this out.

@node    Debugging Your Application, Internals, How to Write OEM Plugins, Top
@chapter Debugging Your Application

OpenIPMI has some things to help you debug your application (and
OpenIPMI itself).  Note that these debugging interfaces are subject to
change.

@menu
* Debug Flags::
* Debugging Locking::
* Seeing IPMI Messages::
@end menu

@node    Debug Flags, Debugging Locking, Debugging Your Application, Debugging Your Application
@section Debug Flags

OpenIPMI has a set of flags you may set to enable or disable certain
debugging information generation.  Debugging information goes to the log
output with IPMI_LOG_DEBUG[_yyy] types.  To enable a flag, do a
@code{DEBUG_xxx_ENABLE()} call, where xxx is the name of the flag.  To
disable a flag, so a @code{DEBUG_XXX_DISABLE()} call.  To check to see
if a flag is enabled (for OEM code, for instance), use the
@var{DEBUG_xxx} macro.

@node    Debugging Locking, Seeing IPMI Messages, Debug Flags, Debugging Your Application
@section Debugging Locking

The LOCKS flag turns on locking (if the @var{IPMI_CHECK_LOCKS}
preprocessor variable is defined, which it is by default).  If you
enable locking, OpenIPMI will check everywhere that the proper locks are
held, and do other checks depending on what low-level OS handling code
is in place, and complain if things aren't right.  You can set a
breakpoint at the function @code{ipmi_report_lock_error()} to have a
debugger stop when a lock problem occurs.

The lock checking is somewhat expensive, and if you want to remove the
calls, you can remove the definition of @var{IPMI_CHECK_LOCKS} from
the file Makefile.am.

@node    Seeing IPMI Messages, , Debugging Locking, Debugging Your Application
@section Seeing IPMI Messages

Two flags control message tracing.  Setting the MSG flag will turn on
message tracing of IPMI messages.  If you turn on RAWMSG, it will trace
low-level messaging, such as LAN resends and any other protocol-type
messages.  This depends on the interface, some interfaces don't
implement raw message tracing.

@node    Internals, Concept Index, Debugging Your Application, Top
@chapter Internals

This section describes the internals of OpenIPMI.  These details are
subject to change, so don't depend on them for writing portable
software.

@menu
* How Locking Works::
@end menu

@node    How Locking Works, , Internals, Internals
@section How Locking Works

The locking in OpenIPMI is currently rather course-grained, for
simplicity.  In the future, it will probably be more fine-grained.

The system has one read/write lock that protects access to the list of
domains.  Every operation locks this lock read (except for the ones that
modify it, which lock it write).  This prevents a domain from going away
while it's in use.

Every domain has an @var{mc_list_lock}, that lock is used to lock all
MC's in the domain.  As well, there is an @var{entities_lock} in the
domain, it is locked for any entities in the domain.

SDRs, since they may stand alone after their underpinnings have been
destroyed, have their own lock.

The various interfaces have their own locks, too, for handling sequence
numbering and the like.  These are interface-dependent and should not
concern the user since they shouldn't be held during user calls.

@node    Concept Index, Glossary,  Internals, Top
@unnumbered Concept Index

@printindex cp

@node    Glossary,       , Concept Index, Top
BMC
domain
connection
callback
discrete sensor
entity
FRU
OpenIPMI id
IPMB
IPMI
LUN
MC
presence sensor
SDR
SEL
slave address
threshold
threshold sensor
@contents
@bye
