.TH ipmi_ui 1 05/13/03 OpenIPMI "Crude interface to an IPMI system"

.SH NAME
ipmi_ui \- Crude interface to an IPMI system

.SH SYNOPSIS
.B ipmiui
[\-dmsg] [\-dmem] [\-c] smi <smi num>

.B ipmiui
[\-dmsg] [\-dmem] [\-c] lan <IP addr> <port> [<IP addr 2> <port 2>]
<auth> <privilege> <username> <password>

.SH DESCRIPTION
The
.BR ipmi_ui
program connects to an IPMI system, and allows access to IPMI entities
and sensors and OpenIPMI controls.  It's rather crude, and primarily
for testing OpenIPMI, but it has some use beyond that so it is
provided.

Normally,
.BR ipmi_ui
starts up in a full-screen format.  The left window shows the output
of commands, the right window shows the logs from OpenIPMI.  Both
windows are scrollable with page up and page down keys, press the "F1"
key to choose the the left window to scroll, the "F2" key to choose
the right window to scroll.

.SH OPTIONS
.TP
.I "\-dmsg"
Turn on message debugging, this will dump all messages to the log window.
.TP
.I "\-dmem"
Turn on memory debugging, this will cause memory allocation and
deallocations to be checked.  When the program terminates, it will
dump all memory that was not properly freed (leaked).
.TP
.I \-c
Run the program in command-line mode.  This is useful for scripting.
All output goes to standard output, there is no windowing.

.TP
.I "smi num"
The SMI number to connect to, for systems with more than on system
interface.  Generally, this is '0'.

.TP
.I "IP addr"
The IP address of the LAN interface.

.TP
.I "port"
The UDP port of the LAN interface, general 623.

.TP
.I "IP addr 2"
Some systems support multiple IP connections, this specified the
second address and is optional.  If specified, OpenIPMI will use both
IP addresses and fail over to the working one if one of them fails.

.TP
.I "port 2"
The port for the second IP connection, generally 623.

.TP
.I "auth"
The authorization to use for the connection, either "none",
"straight", "md5", or "md2".

.TP
.I "privilege"
The privilege to use for the connection, either "callback", "user",
"operator", or "admin".  Note that some IPMI operations will fail
without the correct privilege.

.TP
.I "username"
The user name to use for the connection.  If using this anonymous
user, this should be the empty string "".

.TP
.I "password"
The password to use for the connection.

.SH ENTITIES

Entities are listed by their entity id (the type of entity they are)
and their entity instance.  Entities may be active or inactive in the
system, the standard IPMI algorithm for determining this is used.
Commands on entities are:

.SS entities
List all the entities in the system.  The output is the entity
specifier, followed by an optional entity name in parenthesis,
followed by "present" or "not present".

.SH SENSORS

Sensors define input devices that OpenIPMI can monitor.

.SS sensors <entity>

List all the sensors that monitor the given entity.  The output is the
sensor specifier (the entity specifier followed by the sensor name,
with spaces converted to ~). followed by the sensor name.

.SS sensor <sensor>

Pull up the given sensor and display all its information.  In
full-screen mode, the sensor will be re-queried every second.

.SS rearm <global> [<assertion mask> <deassertion mask>]

Rearm the given sensor.  If
.I "global"
is 1, then the whole sensor is rearmed.  If
.I "global"
is 0, then the
.I "assertion mask"
and
.I "deassertion mask"
must be specified telling which thresholds or states to rearm.

.SS events_enable <events> <scanning> <assertion bitmask> <deassertion bitmask>

Enable or disable events for the given sensor.
.I "events"
turns events on or off from the sensor (0 or 1).
.I "scanning"
turns scanning on or off for the sensor (0 or 1).
.I "assertion bitmask" specifies the bitmask of thresholds or states
that should be enabled or disabled when a thrshold or state is
asserted.  It is a bunch of 0's and 1's, where the first one is for
threshold/state 0, the second for threshold/state 1, etc.
.I "deassertion bitmask" specifies the bitmask of thresholds or states
that should be enabled or disabled when a thrshold or state is
deasserted.

.SH CONTROLS

Controls are output devices that can control things like LEDs, power,
reset lines and such.

.SS controls <entity>

List all the controls that control the given entity.  The output is
the control specifier (the entity specifier followed by the control
name, with spaces converted to ~). followed by the control name.

.SS control <control>

Pull up the given control and display it's current state.

.SS set_control <val1> [<val2> ...]

Change the value of a control.  Note that for controls with multiple
values,
.B every
value must be specified.


.SH EVENTS

Events are asynchronous messages from sensors that tell the user that
a sensor has done something.  Events are generally stored in a system
event log (SEL); OpenIPMI will fetch the events from the SELs in the
system.

Since multiple SELs may exist, an event is specified by the MC it came
from in the format "(channel addr)" and a log number.  The same log
number may exist in multiple MCs.

Events are displayed in the log window as they come in.  If they can
be correlated with a sensor, they will be display with as much
information as possible.

.SS delevent <channel> <mc addr> <log num>

Delete the given event.  Note that many SELs do not support individual
deletes, so this may only delete the local copy of the event, not the
one in the SEL.  In this case, to delete events in the SEL, you must
delete
.B all
the events in the SEL and wait about 10 seconds for OpenIPMI to do a
full SEL clear.

.SS clear_sel

Delete all events in the SEL.  This process may take some time, so
if you do this and quit immediately it may not be complete.

.SS list_sel

List all events in the local copy of the SELs.  This is only the local
copy, if the copies in the actual have change, this won't be reflected.


.SH MANAGMENT CONTROLLERS (MCs)

In OpenIPMI, you normally don't deal with management controllers.
They are considered internal to the system.  However, for debugging,
information about them is provided.

.SS mcs

List all the MCs in the system and whether they are active.  MCs are
displayed in the format "(channel address)".

.SS mc <channel> <mc addr>

Display a boatload of information about the MC, mostly coming from the
get device id command.

.SS mccmd <channel> <mc addr> <LUN> <NetFN> <Cmd> [<data> ...]

Send an IPMI command to the given MC.  The MC must exist and be active
to do this.


.SH OTHER COMMANDS

.SS msg <channel> <IPMB addr> <LUN> <NetFN> <Cmd> [<data> ...]

Send an IPMI command to the given IPMB address.  This is available in
case the given MC cannot be found or enabled.

.SS sdrs <channel> <mc addr> <do sensors>

Dump all the sdrs from the given MC.  If
.I "do sensors"
is true, then dump the device SDR.  If it is false, dump the main SDR
repository on the MC.

.SS scan <channel> <IPMB addr>

Perform an IPMB bus scan for the given IPMB, to try to detect an MC at
the given address.  IPMB bus scanning can be slow, this can help speed
things up if you already know the address.

.SS quit

Leave the program.

.SS reconnect

Attempt to disconnect and reconnect to the IPMI controller.  This is
primarily for testing.

.SS display_win

Set the display window (left window) for scrolling, just in case the
"F1" key doesn't work.

.SS log_win

Set the log window (right window) for scrolling, just in case the "F2"
key doesn't work.

.SS help

Dump some terse help output about all the commands.


.SH "ERROR OUTPUT"
All error output goes to the log window.

.SH "SEE ALSO"
ipmilan(8)

.SH "KNOWN PROBLEMS"
Our name is legion.

.SH AUTHOR
.PP
Corey Minyard <cminyard@mvista.org>
